## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-8},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
OutlierProb
OutlierProb[1,2,]
OutlierProb[2,2,]
OutlierProb[2,3,]
t <- 2
for (i in seq.int(nrow(X))) {
## if assigned to a cluster remove statistics
if ( Outlier[i, t - 1] == 1) {
idx <- Component[i, t - 1] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] - X[i, ]) / (lambdak[idx] - 1)
lambdak[idx] <- lambdak[idx] - 1
nuk[idx] <- nuk[idx] - 1
nk[idx] <- nk[idx] - 1
tau1 <- tau1 - 1
sk[idx, , ] <- sk[idx, , ] - (X[i, ] %*% t(X[i, ])) +
(lambdak[idx] + 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 - 1
}
}
## compute probability of belonging to each organelle
## precompute terms for speed
weight <- (nk + betak)/(sum(nk) + sum(betak) - 1) ## Component weights
sigmak <- ((1 + lambdak) * sk)/(lambdak * (nuk - D + 1)) ## scale matrix
degf <- nuk - D + 1 ## degrees freedom
for (j in seq.int(K)) {
ComponentProb[i, t, j] <- log(weight[j]) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = mk[j, ],
sigma_ = sigmak[j, , ],
df_ = degf[j],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
}
## normalise with underflow correction
c <-  max(ComponentProb[i, t, ])
ComponentProb[i, t , ] <- exp(ComponentProb[i ,t , ] - c) / sum(exp(ComponentProb[i, t, ] - c))
## sample component
Component[i, t] <- sample(x = 1:K, size = 1, prob = ComponentProb[i, t , ] )
## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-8},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
Outlier[i, t] <- sample(x = c(1, 0), 1, prob = OutlierProb[i, t, ]) ## reversed sample so 2nd entry is prob of 0.
## allocation statistics
if ( Outlier[i, t] == 1) {
idx <- Component[i, t] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] + X[i, ]) / (lambdak[idx] + 1)
lambdak[idx] <- lambdak[idx] + 1
nuk[idx] <- nuk[idx] + 1
nk[idx] <- nk[idx] + 1
tau1 <- tau1 + 1
if ( t == 2) {
tau2 <- tau2 - 1 ## default on first round is phi = 0
}
sk[idx, , ] <- sk[idx,,] + (X[i,] %*% t(X[i,])) +
(lambdak[idx] - 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 + 1
}
}
} ## end loop over proteins
OutlierProb[,2,]
cov(exprs(lps))
diag(cov(exprs(lps)))
min(diag(cov(exprs(lps))))
data("hyperLOPIT2015")
min(diag(cov(exprs(hyperLOPIT2015))))
max(diag(cov(exprs(hyperLOPIT2015))))
Outlier
Outlier[,2]
sum(Outlier[,2])
t
t <- 3
for (i in seq.int(nrow(X))) {
## if assigned to a cluster remove statistics
if ( Outlier[i, t - 1] == 1) {
idx <- Component[i, t - 1] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] - X[i, ]) / (lambdak[idx] - 1)
lambdak[idx] <- lambdak[idx] - 1
nuk[idx] <- nuk[idx] - 1
nk[idx] <- nk[idx] - 1
tau1 <- tau1 - 1
sk[idx, , ] <- sk[idx, , ] - (X[i, ] %*% t(X[i, ])) +
(lambdak[idx] + 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 - 1
}
}
## compute probability of belonging to each organelle
## precompute terms for speed
weight <- (nk + betak)/(sum(nk) + sum(betak) - 1) ## Component weights
sigmak <- ((1 + lambdak) * sk)/(lambdak * (nuk - D + 1)) ## scale matrix
degf <- nuk - D + 1 ## degrees freedom
for (j in seq.int(K)) {
ComponentProb[i, t, j] <- log(weight[j]) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = mk[j, ],
sigma_ = sigmak[j, , ],
df_ = degf[j],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
}
## normalise with underflow correction
c <-  max(ComponentProb[i, t, ])
ComponentProb[i, t , ] <- exp(ComponentProb[i ,t , ] - c) / sum(exp(ComponentProb[i, t, ] - c))
## sample component
Component[i, t] <- sample(x = 1:K, size = 1, prob = ComponentProb[i, t , ] )
## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-6},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
Outlier[i, t] <- sample(x = c(1, 0), 1, prob = OutlierProb[i, t, ]) ## reversed sample so 2nd entry is prob of 0.
## allocation statistics
if ( Outlier[i, t] == 1) {
idx <- Component[i, t] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] + X[i, ]) / (lambdak[idx] + 1)
lambdak[idx] <- lambdak[idx] + 1
nuk[idx] <- nuk[idx] + 1
nk[idx] <- nk[idx] + 1
tau1 <- tau1 + 1
if ( t == 2) {
tau2 <- tau2 - 1 ## default on first round is phi = 0
}
sk[idx, , ] <- sk[idx,,] + (X[i,] %*% t(X[i,])) +
(lambdak[idx] - 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 + 1
}
}
} ## end loop over proteins
sum(outlier[,])
sum(outlier[,2])
sum(Outlier[,2])
sum(Outlier[,3])
t <- 4
for (i in seq.int(nrow(X))) {
## if assigned to a cluster remove statistics
if ( Outlier[i, t - 1] == 1) {
idx <- Component[i, t - 1] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] - X[i, ]) / (lambdak[idx] - 1)
lambdak[idx] <- lambdak[idx] - 1
nuk[idx] <- nuk[idx] - 1
nk[idx] <- nk[idx] - 1
tau1 <- tau1 - 1
sk[idx, , ] <- sk[idx, , ] - (X[i, ] %*% t(X[i, ])) +
(lambdak[idx] + 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 - 1
}
}
## compute probability of belonging to each organelle
## precompute terms for speed
weight <- (nk + betak)/(sum(nk) + sum(betak) - 1) ## Component weights
sigmak <- ((1 + lambdak) * sk)/(lambdak * (nuk - D + 1)) ## scale matrix
degf <- nuk - D + 1 ## degrees freedom
for (j in seq.int(K)) {
ComponentProb[i, t, j] <- log(weight[j]) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = mk[j, ],
sigma_ = sigmak[j, , ],
df_ = degf[j],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
}
## normalise with underflow correction
c <-  max(ComponentProb[i, t, ])
ComponentProb[i, t , ] <- exp(ComponentProb[i ,t , ] - c) / sum(exp(ComponentProb[i, t, ] - c))
## sample component
Component[i, t] <- sample(x = 1:K, size = 1, prob = ComponentProb[i, t , ] )
## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-6},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
Outlier[i, t] <- sample(x = c(1, 0), 1, prob = OutlierProb[i, t, ]) ## reversed sample so 2nd entry is prob of 0.
## allocation statistics
if ( Outlier[i, t] == 1) {
idx <- Component[i, t] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] + X[i, ]) / (lambdak[idx] + 1)
lambdak[idx] <- lambdak[idx] + 1
nuk[idx] <- nuk[idx] + 1
nk[idx] <- nk[idx] + 1
tau1 <- tau1 + 1
if ( t == 2) {
tau2 <- tau2 - 1 ## default on first round is phi = 0
}
sk[idx, , ] <- sk[idx,,] + (X[i,] %*% t(X[i,])) +
(lambdak[idx] - 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 + 1
}
}
} ## end loop over proteins
sum(Outlier[,4])
t <- 5
for (i in seq.int(nrow(X))) {
## if assigned to a cluster remove statistics
if ( Outlier[i, t - 1] == 1) {
idx <- Component[i, t - 1] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] - X[i, ]) / (lambdak[idx] - 1)
lambdak[idx] <- lambdak[idx] - 1
nuk[idx] <- nuk[idx] - 1
nk[idx] <- nk[idx] - 1
tau1 <- tau1 - 1
sk[idx, , ] <- sk[idx, , ] - (X[i, ] %*% t(X[i, ])) +
(lambdak[idx] + 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 - 1
}
}
## compute probability of belonging to each organelle
## precompute terms for speed
weight <- (nk + betak)/(sum(nk) + sum(betak) - 1) ## Component weights
sigmak <- ((1 + lambdak) * sk)/(lambdak * (nuk - D + 1)) ## scale matrix
degf <- nuk - D + 1 ## degrees freedom
for (j in seq.int(K)) {
ComponentProb[i, t, j] <- log(weight[j]) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = mk[j, ],
sigma_ = sigmak[j, , ],
df_ = degf[j],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
}
## normalise with underflow correction
c <-  max(ComponentProb[i, t, ])
ComponentProb[i, t , ] <- exp(ComponentProb[i ,t , ] - c) / sum(exp(ComponentProb[i, t, ] - c))
## sample component
Component[i, t] <- sample(x = 1:K, size = 1, prob = ComponentProb[i, t , ] )
## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-6},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
Outlier[i, t] <- sample(x = c(1, 0), 1, prob = OutlierProb[i, t, ]) ## reversed sample so 2nd entry is prob of 0.
## allocation statistics
if ( Outlier[i, t] == 1) {
idx <- Component[i, t] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] + X[i, ]) / (lambdak[idx] + 1)
lambdak[idx] <- lambdak[idx] + 1
nuk[idx] <- nuk[idx] + 1
nk[idx] <- nk[idx] + 1
tau1 <- tau1 + 1
if ( t == 2) {
tau2 <- tau2 - 1 ## default on first round is phi = 0
}
sk[idx, , ] <- sk[idx,,] + (X[i,] %*% t(X[i,])) +
(lambdak[idx] - 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 + 1
}
}
} ## end loop over proteins
sum(Outlier[,5])
t <- 6
for (i in seq.int(nrow(X))) {
## if assigned to a cluster remove statistics
if ( Outlier[i, t - 1] == 1) {
idx <- Component[i, t - 1] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] - X[i, ]) / (lambdak[idx] - 1)
lambdak[idx] <- lambdak[idx] - 1
nuk[idx] <- nuk[idx] - 1
nk[idx] <- nk[idx] - 1
tau1 <- tau1 - 1
sk[idx, , ] <- sk[idx, , ] - (X[i, ] %*% t(X[i, ])) +
(lambdak[idx] + 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 - 1
}
}
## compute probability of belonging to each organelle
## precompute terms for speed
weight <- (nk + betak)/(sum(nk) + sum(betak) - 1) ## Component weights
sigmak <- ((1 + lambdak) * sk)/(lambdak * (nuk - D + 1)) ## scale matrix
degf <- nuk - D + 1 ## degrees freedom
for (j in seq.int(K)) {
ComponentProb[i, t, j] <- log(weight[j]) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = mk[j, ],
sigma_ = sigmak[j, , ],
df_ = degf[j],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
}
## normalise with underflow correction
c <-  max(ComponentProb[i, t, ])
ComponentProb[i, t , ] <- exp(ComponentProb[i ,t , ] - c) / sum(exp(ComponentProb[i, t, ] - c))
## sample component
Component[i, t] <- sample(x = 1:K, size = 1, prob = ComponentProb[i, t , ] )
## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-6},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
Outlier[i, t] <- sample(x = c(1, 0), 1, prob = OutlierProb[i, t, ]) ## reversed sample so 2nd entry is prob of 0.
## allocation statistics
if ( Outlier[i, t] == 1) {
idx <- Component[i, t] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] + X[i, ]) / (lambdak[idx] + 1)
lambdak[idx] <- lambdak[idx] + 1
nuk[idx] <- nuk[idx] + 1
nk[idx] <- nk[idx] + 1
tau1 <- tau1 + 1
if ( t == 2) {
tau2 <- tau2 - 1 ## default on first round is phi = 0
}
sk[idx, , ] <- sk[idx,,] + (X[i,] %*% t(X[i,])) +
(lambdak[idx] - 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 + 1
}
}
} ## end loop over proteins
Outlier[,6]
sum(Outlier[,6])
for (t in seq.int(7, 10)) {
## consider each protein in turn
for (i in seq.int(nrow(X))) {
## if assigned to a cluster remove statistics
if ( Outlier[i, t - 1] == 1) {
idx <- Component[i, t - 1] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] - X[i, ]) / (lambdak[idx] - 1)
lambdak[idx] <- lambdak[idx] - 1
nuk[idx] <- nuk[idx] - 1
nk[idx] <- nk[idx] - 1
tau1 <- tau1 - 1
sk[idx, , ] <- sk[idx, , ] - (X[i, ] %*% t(X[i, ])) +
(lambdak[idx] + 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 - 1
}
}
## compute probability of belonging to each organelle
## precompute terms for speed
weight <- (nk + betak)/(sum(nk) + sum(betak) - 1) ## Component weights
sigmak <- ((1 + lambdak) * sk)/(lambdak * (nuk - D + 1)) ## scale matrix
degf <- nuk - D + 1 ## degrees freedom
for (j in seq.int(K)) {
ComponentProb[i, t, j] <- log(weight[j]) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = mk[j, ],
sigma_ = sigmak[j, , ],
df_ = degf[j],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
}
## normalise with underflow correction
c <-  max(ComponentProb[i, t, ])
ComponentProb[i, t , ] <- exp(ComponentProb[i ,t , ] - c) / sum(exp(ComponentProb[i, t, ] - c))
## sample component
Component[i, t] <- sample(x = 1:K, size = 1, prob = ComponentProb[i, t , ] )
## compute outlier allocation
n <- nrow(object)
idk <- Component[i, t] ## temporary allocation variable
OutlierProb[i, t, 1] <- log((tau1 + v)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop=FALSE],
mu_ = mk[idk, ],
sigma_ = sigmak[idk,,],
df_ = degf[idk],
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
OutlierProb[i, t, 2] <- log((tau2 + u)/(n + u + v - 1)) + dmvtCpp(X[i, ,drop = FALSE],
mu_ = M,
sigma_ = V + diag(10^{-6},60),
df_ = 4,
log_ = TRUE,
ncores_ = 1,
isChol_ = FALSE)
## normalise and sample
OutlierProb[i, t, ] <- exp(OutlierProb[i, t, ])/sum(exp(OutlierProb[i, t, ]))
Outlier[i, t] <- sample(x = c(1, 0), 1, prob = OutlierProb[i, t, ]) ## reversed sample so 2nd entry is prob of 0.
## allocation statistics
if ( Outlier[i, t] == 1) {
idx <- Component[i, t] ## temporary variable index
tempS <- mk[idx, ] %*% t(mk[idx, ]) ## temporary scatter, since mk to be update on next line
mk[idx, ] <- (lambdak[idx] * mk[idx, ] + X[i, ]) / (lambdak[idx] + 1)
lambdak[idx] <- lambdak[idx] + 1
nuk[idx] <- nuk[idx] + 1
nk[idx] <- nk[idx] + 1
tau1 <- tau1 + 1
if ( t == 2) {
tau2 <- tau2 - 1 ## default on first round is phi = 0
}
sk[idx, , ] <- sk[idx,,] + (X[i,] %*% t(X[i,])) +
(lambdak[idx] - 1) * tempS  - lambdak[idx] * mk[idx,] %*% t(mk[idx,])
} else {
if (t > 2) {
tau2 <- tau2 + 1
}
}
} ## end loop over proteins
} ## end iterations
colSums(Outlier)
roxygen2::roxygenise()
roxygen2::roxygenise(package.dir = "Documents/pRoloc")
roxygen2::roxygenise(package.dir = "../Documents/pRoloc")
setwd("~/pRoloc")
roxygen2::roxygenise()
