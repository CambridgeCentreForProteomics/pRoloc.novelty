<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A transfer learning algorithm for spatial proteomics • pRoloc</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">pRoloc</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/lgatto/pRoloc">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>A transfer learning algorithm for spatial proteomics</h1>
                        <h4 class="author">Lisa M. Breckels</h4>
            <address class="author_afil">
      Computational Proteomics Unit, Cambridge, UK<br><h4 class="author">Laurent Gatto</h4>
            <address class="author_afil">
      Computational Proteomics Unit, Cambridge, UK<br>
</address>
</address>
</div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>This vignette illustrates the application of a <em>transfer learning</em> algorithm to assign proteins to sub-cellular localisations. The <em>knntlClassification</em> algorithm combines <em>primary</em> experimental spatial proteomics data (LOPIT, PCP, etc.) and an <em>auxiliary</em> data set (for example binary data based on Gene Ontology terms) to improve the sub-cellular assignment given an optimal combination of these data sources.</p>
    </div>
    
<div class="contents">
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelector("h1").className = "title";
});
</script><script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
  var links = document.links;  
  for (var i = 0, linksLength = links.length; i < linksLength; i++)
    if (links[i].hostname != window.location.hostname)
      links[i].target = '_blank';
});
</script><div id="sec:intro" class="section level1">
<h1 class="hasAnchor">
<html><body><a href="#sec:intro" class="anchor"> </a></body></html>Introduction</h1>
<p>Our main data source to study protein sub-cellular localisation are high-throughput mass spectrometry-based experiments such as LOPIT, PCP and similar designs (see <span class="citation">(L. Gatto et al. 2010)</span> for an general introduction). Recent optimised experiments result in high quality data enabling the identification of over 6000 proteins and discriminate numerous sub-cellular and sub-organellar niches <span class="citation">(A. Christoforou et al. 2016)</span>. Supervised and semi-supervised machine learning algorithms can be applied to assign thousands of proteins to annotated sub-cellular niches <span class="citation">(L. M. Breckels et al. 2013,Gatto:2014)</span> (see also the <em>pRoloc-tutorial</em> vignette). These data constitute our main source for protein localisation and are termed thereafter <em>primary</em> data.</p>
<p>There are other sources of data about sub-cellular localisation of proteins, such as the Gene Ontology <span class="citation">(Ashburner et al. 2000)</span> (in particular the cellular compartment name space), quantitative features derived from protein sequences (such as pseudo amino acid composition) or the Human Protein Atlas <span class="citation">(Uhlen et al. 2010)</span> to cite a few. These data, while not optimised to a specific system at hand and, in the case of annotation feature, not as reliable as our experimental data, constitute an invaluable, often plentiful source of <em>auxiliary</em> information.</p>
<p>The aim of a <em>transfer learning</em> algorithm is to combine different sources of data to improve overall classification. In particular, the goal is to support/complement the primary target domain (experimental data) with auxiliary data (annotation) features without compromising the integrity of our primary data. In this vignette, we describe the application of transfer learning algorithms for the localisation of proteins from the <em><a href="http://bioconductor.org/packages/pRoloc">pRoloc</a></em> package, as described in</p>
<blockquote>
<p>Breckels LM, Holden S, Wonjar D, Mulvey CM, Christoforou A, Groen A, Trotter MW, Kohlbacker O, Lilley KS and Gatto L (2016). <em>Learning from heterogeneous data sources: an application in spatial proteomics</em>. PLoS Comput Biol 13;12(5):e1004920. doi: <a href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004920">10.1371/journal.pcbi.1004920</a>.</p>
</blockquote>
<p>Two algorithms were developed: a transfer learning algorithm based on the <span class="math inline">\(k\)</span>-nearest neighbour classifier, coined kNN-TL hereafter, described in section @ref(sec:knntl), and one based on the support vector machine algorithm, termed SVM-TL, described in section @ref(sec:svmtl).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"pRoloc"</span>)</code></pre></div>
</div>
<div id="sec:aux" class="section level1">
<h1 class="hasAnchor">
<html><body><a href="#sec:aux" class="anchor"> </a></body></html>Preparing the auxiliary data</h1>
<div id="sec:goaux" class="section level2">
<h2 class="hasAnchor">
<html><body><a href="#sec:goaux" class="anchor"> </a></body></html>The Gene Ontology</h2>
<p>The auxiliary data is prepared from the primary data’s features. All the GO terms associated to these features are retrieved and used to create a binary matrix where a one (zero) at position <span class="math inline">\((i,j)\)</span> indicates that term <span class="math inline">\(j\)</span> has (not) been used to annotate feature <span class="math inline">\(i\)</span>.</p>
<p>The GO terms are retrieved from an appropriate repository using the <em><a href="http://bioconductor.org/packages/biomaRt">biomaRt</a></em> package. The specific Biomart repository and query will depend on the species under study and the type of features. The first step is to prepare annotation parameters that will enable to perform the query. The <em><a href="http://bioconductor.org/packages/pRoloc">pRoloc</a></em> package provides a dedicated infrastructure to set up the query to the annotation resource and prepare the GO data for subsequent analyses. This infrastructure is composed of:</p>
<ol style="list-style-type: decimal">
<li>define the annotation parameters based on the species and feature types;</li>
<li>query the resource defined in (1) to retrieve relevant terms and use the terms to prepare the auxiliary data.</li>
</ol>
<p>We will demonstrate these steps using a LOPIT experiment on Human Embryonic Kidney (HEK293T) fibroblast cells <span class="citation">(L. M. Breckels et al. 2013)</span>, available and documented in the <em><a href="http://bioconductor.org/packages/pRolocdata">pRolocdata</a></em> experiment package as <code>andy2011</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"pRolocdata"</span>)
<span class="kw">data</span>(andy2011)</code></pre></div>
<div id="sec:ap" class="section level3">
<h3 class="hasAnchor">
<html><body><a href="#sec:ap" class="anchor"> </a></body></html>Preparing the query parameters</h3>
<p>The query parameters are stored as <em>AnnotationParams</em> objects that are created with the <em>setAnnotationParams</em> function. The function will present a first menu with 215. Once the species has been selected, a set of possible identifier types is displayed.</p>
<div class="figure">
<img src="Figures/ap12.png" alt="Selecting species (left) and feature type (right) to create an AnnotationParams instance for the human andy2011 data." id="fig:apgui"><p class="caption">Selecting species (left) and feature type (right) to create an <code>AnnotationParams</code> instance for the human <code>andy2011</code> data.</p>
</div>
<p>It is also possible to pass patterns to match against the species (<code>"Homo sapiens"</code>) and feature type (<code>"UniProtKB/Swiss-prot ID"</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ap &lt;-<span class="st"> </span><span class="kw"><a href="../reference/AnnotationParams-class.html">setAnnotationParams</a></span>(<span class="dt">inputs =</span>
                              <span class="kw">c</span>(<span class="st">"Homo sapiens"</span>,
                                <span class="st">"UniProtKB/Swiss-Prot ID"</span>))</code></pre></div>
<pre><code>## Using species Homo sapiens genes (GRCh38.p5)</code></pre>
<pre><code>## Using feature type UniProtKB/Swiss-Prot ID(s) [e.g. A0A075B6P5]</code></pre>
<pre><code>## Connecting to Biomart...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ap</code></pre></div>
<pre><code>## Object of class "AnnotationParams"
##  Using the 'ENSEMBL_MART_ENSEMBL' BioMart database
##  Using the 'hsapiens_gene_ensembl' dataset
##  Using 'uniprotswissprot' as filter
##  Created on Fri May 26 12:03:28 2017</code></pre>
<p>The <em>setAnnotationParams</em> function automatically sets the annotation parameters globally so that the <code>ap</code> object does not need to be explicitly set later on. The default parameters can be retrieved with <em>getAnnotationParams</em>.</p>
</div>
<div id="sec:auxgo" class="section level3">
<h3 class="hasAnchor">
<html><body><a href="#sec:auxgo" class="anchor"> </a></body></html>Preparing the auxiliary data from the GO ontology</h3>
<p>The feature names of the <code>andy2011</code> data are UniProt identifiers, as defined in the <code>ap</code> accession parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(andy2011)
<span class="kw">head</span>(<span class="kw">featureNames</span>(andy2011))</code></pre></div>
<pre><code>## [1] "O00767" "P51648" "Q2TAA5" "Q9UKV5" "Q12797" "P16615"</code></pre>
<p>The <em>makeGoSet</em> function takes an <em>MSnSet</em> class (from which the feature names will be extracted) or, directly a vector of characters containing the feature names of interest to retrieve the associated GO terms and construct an auxiliary <code>MSnSet</code>. By default, it downloads <em>cellular component</em> terms and does not do any filtering on the terms evidence codes (see the <em>makeGoSet</em> manual for details). Unless passed as argument, the default, globally set <em>AnnotationParams</em> are used to define the Biomart server and the query.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">andygoset &lt;-<span class="st"> </span><span class="kw"><a href="../reference/makeGoSet.html">makeGoSet</a></span>(andy2011)
andygoset</code></pre></div>
<pre><code>## MSnSet (storageMode: lockedEnvironment)
## assayData: 1371 features, 796 samples 
##   element names: exprs 
## protocolData: none
## phenoData: none
## featureData
##   featureNames: O00767 P51648 ... O75312 (1371 total)
##   fvarLabels: Accession.No. Protein.Description ...
##     UniProtKB.entry.name (10 total)
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'
## Annotation:  
## - - - Processing information - - -
## Constructed GO set using cellular_component namespace [Fri May 26 12:03:33 2017] 
##  MSnbase version: 2.3.2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exprs</span>(andygoset)[<span class="dv">1</span><span class="op">:</span><span class="dv">7</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<pre><code>##        GO:0016021 GO:0016020 GO:0005789 GO:0005783
## O00767          1          1          1          1
## P51648          1          1          1          1
## Q2TAA5          1          1          1          1
## Q9UKV5          1          1          1          1
## Q12797          1          1          1          1
## P16615          1          1          1          1
## Q96SQ9          0          1          1          1</code></pre>
<p>We now have a primary data set, composed of 1371 protein quantitative profiles for 8 fractions along the density gradient and an auxiliary data set for 796 cellular compartment GO terms for the same 1371 features.</p>
</div>
<div id="sec:annotrepro" class="section level3">
<h3 class="hasAnchor">
<html><body><a href="#sec:annotrepro" class="anchor"> </a></body></html>A note on reproducibility</h3>
<p>The generation of the auxiliary data relies on specific Biomart server <em>Mart</em> instances in the <em>AnnotationParams</em> class and the actual query to the server to obtain the GO terms associated with the features. The utilisation of online servers, which undergo regular updates, does not guarantee reproducibility of feature/term association over time. It is recommended to save and store the <em>AnnotationParams</em> and auxiliary <em>MSnSet</em> instances. Alternatively, it is possible to use other Bioconductor infrastructure, such as specific organism annotations and the <em><a href="http://bioconductor.org/packages/GO.db">GO.db</a></em> package to use specific versioned (and thus traceable) annotations.</p>
</div>
</div>
<div id="sec:hpaaux" class="section level2">
<h2 class="hasAnchor">
<html><body><a href="#sec:hpaaux" class="anchor"> </a></body></html>The Human Protein Atlas</h2>
<p>The feature names of our LOPIT experiment are UniProt identifiers, while the Human Protein Atlas uses Ensembl gene identifiers. This first code chunk matches both identifier types using the Ensembl Biomart server. In this section, we copy the experimental data to <code>andyhpa</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">andyhpa &lt;-<span class="st"> </span>andy2011
<span class="kw">fvarLabels</span>(andyhpa)[<span class="dv">1</span>] &lt;-<span class="st"> "accession"</span> ## for left_join matching
## convert protein accession numbers to ensembl gene identifiers

<span class="kw">library</span>(<span class="st">"biomaRt"</span>)
mart &lt;-<span class="st"> </span><span class="kw">useMart</span>(<span class="st">"ensembl"</span>, <span class="dt">dataset =</span> <span class="st">"hsapiens_gene_ensembl"</span>)

filter &lt;-<span class="st"> "uniprotswissprot"</span>
attrib &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"uniprot_gn"</span>, <span class="st">"uniprotswissprot"</span>, <span class="st">"ensembl_gene_id"</span>)
bm &lt;-<span class="st"> </span><span class="kw">getBM</span>(<span class="dt">attributes =</span> attrib,
            <span class="dt">filters =</span> filter,
            <span class="dt">values =</span> <span class="kw">fData</span>(andyhpa)[, <span class="st">"accession"</span>],
            <span class="dt">mart =</span> mart)
<span class="kw">head</span>(bm)</code></pre></div>
<pre><code>##   uniprot_gn uniprotswissprot ensembl_gene_id
## 1                      A0FGR8 ENSG00000117868
## 2     A6NCS6           A6NCS6 ENSG00000204128
## 3     O00116           O00116 ENSG00000018510
## 4                      O00468 ENSG00000188157
## 5     O00469           O00469 ENSG00000152952
## 6     O00767           O00767 ENSG00000099194</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## HPA data
<span class="kw">library</span>(<span class="st">"hpar"</span>)</code></pre></div>
<pre><code>## This is hpar version 1.19.0,
## based on the Human Protein Atlas
##   Version: 16.1
##   Release data: 2017.01.31
##   Ensembl build: 83.38
## See '?hpar' or 'vignette('hpar')' for details.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## using old version for traceability
<span class="kw">setHparOptions</span>(<span class="dt">hpadata =</span> <span class="st">"hpaSubcellularLoc14"</span>)
hpa &lt;-<span class="st"> </span><span class="kw">getHpa</span>(bm<span class="op">$</span>ensembl_gene_id)
hpa<span class="op">$</span>Reliability &lt;-<span class="st"> </span><span class="kw">droplevels</span>(hpa<span class="op">$</span>Reliability)
<span class="kw">colnames</span>(hpa)[<span class="dv">1</span>] &lt;-<span class="st"> "ensembl_gene_id"</span>

<span class="kw">library</span>(<span class="st">"dplyr"</span>)
hpa &lt;-<span class="st"> </span><span class="kw">left_join</span>(hpa, bm)</code></pre></div>
<pre><code>## Joining, by = "ensembl_gene_id"</code></pre>
<pre><code>## Warning in left_join_impl(x, y, by$x, by$y, suffix$x, suffix$y): joining
## character vector and factor, coercing into character vector</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hpa &lt;-<span class="st"> </span>hpa[<span class="op">!</span><span class="kw">duplicated</span>(hpa<span class="op">$</span>uniprotswissprot), ]

## match HPA/LOPIT
<span class="kw">colnames</span>(hpa)[<span class="dv">7</span>] &lt;-<span class="st"> "accession"</span>
fd &lt;-<span class="st"> </span><span class="kw">left_join</span>(<span class="kw">fData</span>(andyhpa), hpa)</code></pre></div>
<pre><code>## Joining, by = "accession"</code></pre>
<pre><code>## Warning in left_join_impl(x, y, by$x, by$y, suffix$x, suffix$y): joining
## character vector and factor, coercing into character vector</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rownames</span>(fd) &lt;-<span class="st"> </span><span class="kw">featureNames</span>(andyhpa)
<span class="kw">fData</span>(andyhpa) &lt;-<span class="st"> </span>fd
<span class="kw">stopifnot</span>(<span class="kw">validObject</span>(andyhpa))

## Let's get rid of features without any hpa data
lopit &lt;-<span class="st"> </span>andyhpa[<span class="op">!</span><span class="kw">is.na</span>(<span class="kw">fData</span>(andyhpa)<span class="op">$</span>Main.location), ]</code></pre></div>
<p>Below, we deparse the multiple ‘;’-delimited locations contained in the Human Protein sub-cellular Atlas, create the auxiliary binary data matrix (only localisations with reliability equal to <em>Supportive</em> are considered; <em>Uncertain</em> assignments are ignored - see <a href="http://www.proteinatlas.org/about/antibody+validation" class="uri">http://www.proteinatlas.org/about/antibody+validation</a> for details) and filter proteins without any localisation data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## HPA localisation
hpalocs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">as.character</span>(<span class="kw">fData</span>(lopit)<span class="op">$</span>Main.location),
             <span class="kw">as.character</span>(<span class="kw">fData</span>(lopit)<span class="op">$</span>Other.location))
hpalocs &lt;-<span class="st"> </span>hpalocs[<span class="op">!</span><span class="kw">is.na</span>(hpalocs)]
hpalocs &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">unlist</span>(<span class="kw">strsplit</span>(hpalocs, <span class="st">";"</span>)))

makeHpaSet &lt;-<span class="st"> </span><span class="cf">function</span>(x, score2, <span class="dt">locs =</span> hpalocs) {
    hpamat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">ncol =</span> <span class="kw">length</span>(locs), <span class="dt">nrow =</span> <span class="kw">nrow</span>(x))
    <span class="kw">colnames</span>(hpamat) &lt;-<span class="st"> </span>locs
    <span class="kw">rownames</span>(hpamat) &lt;-<span class="st"> </span><span class="kw">featureNames</span>(x)    
    <span class="cf">for</span>  (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(hpamat)) {
        loc &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">strsplit</span>(<span class="kw">as.character</span>(<span class="kw">fData</span>(x)[i, <span class="st">"Main.location"</span>]), <span class="st">";"</span>))
        loc2 &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">strsplit</span>(<span class="kw">as.character</span>(<span class="kw">fData</span>(x)[i, <span class="st">"Other.location"</span>]), <span class="st">";"</span>))
        score &lt;-<span class="st"> </span>score2[<span class="kw">fData</span>(x)[i, <span class="st">"Reliability"</span>]]
        hpamat[i, loc] &lt;-<span class="st"> </span>score
        hpamat[i, loc2] &lt;-<span class="st"> </span>score
    }
    <span class="kw">new</span>(<span class="st">"MSnSet"</span>, <span class="dt">exprs =</span> hpamat,
        <span class="dt">featureData =</span> <span class="kw">featureData</span>(x))
}

hpaset &lt;-<span class="st"> </span><span class="kw">makeHpaSet</span>(lopit,
                     <span class="dt">score2 =</span> <span class="kw">c</span>(<span class="dt">Supportive =</span> <span class="dv">1</span>, <span class="dt">Uncertain =</span> <span class="dv">0</span>))
hpaset &lt;-<span class="st"> </span><span class="kw"><a href="../reference/filterZeroCols.html">filterZeroRows</a></span>(hpaset)</code></pre></div>
<pre><code>## Removing 319 columns with only 0s.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(hpaset)</code></pre></div>
<pre><code>## [1] 668  18</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exprs</span>(hpaset)[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">200</span>), <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]</code></pre></div>
<pre><code>##        Endoplasmic reticulum Cytoplasm Vesicles
## O00767                     1         0        0
## O95302                     0         0        1
## P06493                     0         1        0</code></pre>
</div>
<div id="sec:ppi" class="section level2">
<h2 class="hasAnchor">
<html><body><a href="#sec:ppi" class="anchor"> </a></body></html>Protein-protein interactions</h2>
<p>Protein-protein interaction data can also be used as auxiliary data input to the transfer learning algorithm. Several sources can be used to do so directly from R:</p>
<ul>
<li><p>The <em><a href="http://bioconductor.org/packages/PSICQUIC">PSICQUIC</a></em> package provides an R interfaces to the HUPO Proteomics Standard Initiative (HUPO-PSI) project, which standardises programmatic access to molecular interaction databases. This approach enables to query great many resources in one go but, as noted in the vignettes, for bulk interactions, it is recommended to directly download databases from individual PSICQUIC providers.</p></li>
<li><p>The <em><a href="http://bioconductor.org/packages/STRINGdb">STRINGdb</a></em> package provides a direct interface to the STRING protein-protein interactions database. This package can be used to generate a table as the one used below. The exact procedure is described in the <code>STRINGdb</code> vignette and involves mapping the protein identifiers with the <em>map</em> and retrieve the interaction partners with the <em>get_neighbors</em> method.</p></li>
<li><p>Finally, it is possible to use any third-party PPI inference results and adequately prepare these results for transfer learning. Below, we will described this case with PPI data in a tab-delimited format, as retrieved directly from the STRING database.</p></li>
</ul>
<p>Below, we access the PPI spreadsheet file for our test data, that is distributed with the <em><a href="http://bioconductor.org/packages/pRolocdata">pRolocdata</a></em> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ppif &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">"extdata/tabdelimited._gHentss2F9k.txt.gz"</span>, <span class="dt">package =</span> <span class="st">"pRolocdata"</span>)
ppidf &lt;-<span class="st"> </span><span class="kw">read.delim</span>(ppif, <span class="dt">header =</span> <span class="ot">TRUE</span>, <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
<span class="kw">head</span>(ppidf)</code></pre></div>
<pre><code>##   X.node1  node2 node1_string_id node2_string_id node1_external_id
## 1   NUDT5 IMPDH2         1861432         1850365   ENSP00000419628
## 2    NOP2  RPL23         1858730         1858184   ENSP00000382392
## 3   HSPA4   ENO1         1848476         1843405   ENSP00000302961
## 4   RPS13   DKC1         1862013         1855055   ENSP00000435777
## 5  RPL35A  DDOST         1859718         1856225   ENSP00000393393
## 6  RPL13A   RPS6         1857955         1857216   ENSP00000375730
##   node2_external_id neighborhood fusion cooccurence homology coexpression
## 1   ENSP00000321584        0.000      0           0        0        0.112
## 2   ENSP00000377865        0.000      0           0        0        0.064
## 3   ENSP00000234590        0.000      0           0        0        0.109
## 4   ENSP00000358563        0.462      0           0        0        0.202
## 5   ENSP00000364188        0.000      0           0        0        0.000
## 6   ENSP00000369757        0.000      0           0        0        0.931
##   experimental knowledge textmining combined_score
## 1        0.000       0.0      0.370          0.416
## 2        0.868       0.0      0.000          0.871
## 3        0.222       0.0      0.436          0.575
## 4        0.000       0.0      0.354          0.698
## 5        0.000       0.9      0.265          0.923
## 6        0.419       0.9      0.240          0.996</code></pre>
<p>The file contains 18623 pairwise interactions and the STRING combined interaction score. Below, we create a contingency matrix that uses these scores to encode and weight interactions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">uid &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">c</span>(ppidf<span class="op">$</span>X.node1, ppidf<span class="op">$</span>node2))
ppim &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="kw">length</span>(uid))
<span class="kw">colnames</span>(ppim) &lt;-<span class="st"> </span><span class="kw">rownames</span>(ppim) &lt;-<span class="st"> </span>uid

<span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ppidf)) {
    i &lt;-<span class="st"> </span>ppidf[[k, <span class="st">"X.node1"</span>]]
    j &lt;-<span class="st"> </span>ppidf[[k, <span class="st">"node2"</span>]]
    ppim[i, j] &lt;-<span class="st"> </span>ppidf[[k, <span class="st">"combined_score"</span>]]
}

ppim[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">8</span>]</code></pre></div>
<pre><code>##        NUDT5 NOP2 HSPA4 RPS13 RPL35A RPL13A CPS1 CTNNB1
## NUDT5      1    0     0     0  0.000  0.000    0      0
## NOP2       0    1     0     0  0.000  0.000    0      0
## HSPA4      0    0     1     0  0.000  0.000    0      0
## RPS13      0    0     0     1  0.997  0.998    0      0
## RPL35A     0    0     0     0  1.000  0.999    0      0</code></pre>
<p>We now have a contingency matrix reflecting a total of 19910 interactions between 1287 proteins. Below, we only keep proteins that are also available in our spatial proteomics data (renamed to <code>andyppi</code>), subset the PPI and LOPIT data, create the appropriate <code>MSnSet</code> object, and filter out proteins without any interaction scores.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">andyppi &lt;-<span class="st"> </span>andy2011
<span class="kw">featureNames</span>(andyppi) &lt;-<span class="st"> </span><span class="kw">sub</span>(<span class="st">"_HUMAN"</span>, <span class="st">""</span>, <span class="kw">fData</span>(andyppi)<span class="op">$</span>UniProtKB.entry.name)
cmn &lt;-<span class="st"> </span><span class="kw">intersect</span>(<span class="kw">featureNames</span>(andyppi), <span class="kw">rownames</span>(ppim))
ppim &lt;-<span class="st"> </span>ppim[cmn, ]
andyppi &lt;-<span class="st"> </span>andyppi[cmn, ]

ppi &lt;-<span class="st"> </span><span class="kw">MSnSet</span>(ppim, <span class="dt">fData =</span> <span class="kw">fData</span>(andyppi),
              <span class="dt">pData =</span> <span class="kw">data.frame</span>(<span class="dt">row.names =</span> <span class="kw">colnames</span>(ppim)))
ppi &lt;-<span class="st"> </span><span class="kw"><a href="../reference/filterZeroCols.html">filterZeroCols</a></span>(ppi)</code></pre></div>
<pre><code>## Removing 178 columns with only 0s.</code></pre>
<p>We now have two <code>MSnSet</code> objects containing respectively 520 primary experimental protein profiles along a sub-cellular density gradient (<code>andyppi</code>) and 520 auxiliary interaction profiles (<code>ppi</code>).</p>
</div>
</div>
<div id="sec:svmtl" class="section level1">
<h1 class="hasAnchor">
<html><body><a href="#sec:svmtl" class="anchor"> </a></body></html>Support vector machine transfer learning</h1>
<p>The SVM-TL method descibed in <span class="citation">(Breckels et al. 2016)</span> has not yet been incorporated in the <em><a href="http://bioconductor.org/packages/pRoloc">pRoloc</a></em> package. The code implementing the method is currently available in its own repository:</p>
<p><a href="https://github.com/ComputationalProteomicsUnit/lpsvm-tl-code" class="uri">https://github.com/ComputationalProteomicsUnit/lpsvm-tl-code</a></p>
</div>
<div id="sec:knntl" class="section level1">
<h1 class="hasAnchor">
<html><body><a href="#sec:knntl" class="anchor"> </a></body></html>Nearest neighbour transfer learning</h1>
<div id="sec:theopt" class="section level2">
<h2 class="hasAnchor">
<html><body><a href="#sec:theopt" class="anchor"> </a></body></html>Optimal weights</h2>
<p>The weighted nearest neighbours transfer learning algorithm estimates optimal weights for the different data sources and the spatial niches described for the data at hand with the <em>knntlOptimisation</em> function. For instance, for the human data modelled by the <code>andy2011</code> and <code>andygoset</code> objects<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> and the 10 annotated sub-cellular localisations (Golgi, Mitochondrion, PM, Lysosome, Cytosol, Cytosol/Nucleus, Nucleus, Ribosome 60S, Ribosome 40S and ER), we want to know how to optimally combine primary and auxiliary data. If we look at figure @ref(fig:andypca), that illustrates the experimental separation of the 10 spatial classes on a principal component plot, we see that some organelles such as the mitochondrion or the cytosol and cytosol/nucleus are well resolved, while others such as the Golgi or the ER are less so. In this experiment, the former classes are not expected to benefit from another data source, while the latter should benefit from additional information.</p>
<div class="figure">
<img src="pRoloc-transfer-learning_files/figure-html/andypca-1.png" alt="PCA plot of `andy2011`. The multivariate protein profiles are summarised along the two first principal components. Proteins of unknown localisation are represented by empty grey points. Protein markers, which are well-known residents of specific sub-cellular niches are colour-coded and form clusters on the figure." width="672"><p class="caption">
PCA plot of <code>andy2011</code>. The multivariate protein profiles are summarised along the two first principal components. Proteins of unknown localisation are represented by empty grey points. Protein markers, which are well-known residents of specific sub-cellular niches are colour-coded and form clusters on the figure.
</p>
</div>
<p>Let’s define a set of three possible weights: 0, 0.5 and 1. A weight of 1 indicates that the final results rely exclusively on the experimental data and ignore completely the auxiliary data. A weight of 0 represents the opposite situation, where the primary data is ignored and only the auxiliary data is considered. A weight of 0.5 indicates that each data source will contribute equally to the final results. It is the algorithm’s optimisation step task to identify the optimal combination of class-specific weights for a given primary and auxiliary data pair. The optimisation process can be quite time consuming for many weights and many sub-cellular classes, as all combinations (there are <span class="math inline">\(number~of~classes^{number~of~weights}\)</span> possibilities; see below). One would generally defined more weights (for example 0, 0.25, 0.5, 0.75, 1 or 0, 0.33, 0.67, 1) to explore more fine-grained integration opportunities. The possible weight combinations can be calculated with the <em>thetas</em> function:</p>
<ul>
<li>3 classes, 3 weights</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/thetas.html">thetas</a></span>(<span class="dv">3</span>, <span class="dt">by =</span> <span class="fl">0.5</span>))</code></pre></div>
<pre><code>## Weigths:
##   (0, 0.5, 1)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0  0.0  0.0
## [2,]    0  0.0  0.5
## [3,]    0  0.0  1.0
## [4,]    0  0.5  0.0
## [5,]    0  0.5  0.5
## [6,]    0  0.5  1.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(<span class="kw"><a href="../reference/thetas.html">thetas</a></span>(<span class="dv">3</span>, <span class="dt">by =</span> <span class="fl">0.5</span>))</code></pre></div>
<pre><code>## Weigths:
##   (0, 0.5, 1)</code></pre>
<pre><code>## [1] 27  3</code></pre>
<ul>
<li>5 classes, 4 weights</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(<span class="kw"><a href="../reference/thetas.html">thetas</a></span>(<span class="dv">5</span>, <span class="dt">length.out =</span> <span class="dv">4</span>))</code></pre></div>
<pre><code>## Weigths:
##   (0, 0.333333333333333, 0.666666666666667, 1)</code></pre>
<pre><code>## [1] 1024    5</code></pre>
<ul>
<li>for the human <code>andy2011</code> data, considering 4 weights, there are very many combinations:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## marker classes for andy2011
m &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">fData</span>(andy2011)<span class="op">$</span>markers.tl)
m &lt;-<span class="st"> </span>m[m <span class="op">!=</span><span class="st"> "unknown"</span>]
th &lt;-<span class="st"> </span><span class="kw"><a href="../reference/thetas.html">thetas</a></span>(<span class="kw">length</span>(m), <span class="dt">length.out=</span><span class="dv">4</span>)</code></pre></div>
<pre><code>## Weigths:
##   (0, 0.333333333333333, 0.666666666666667, 1)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(th)</code></pre></div>
<pre><code>## [1] 1048576      10</code></pre>
<p>The actual combination of weights to be tested can be defined in multiple ways: by passing a weights matrix explicitly (as those generated with <em>thetas</em> above) through the <code>th</code> argument; or by defining the increment between weights using <code>by</code>; or by specifying the number of weights to be used through the <code>length.out</code> argument.</p>
<p>Considering the sub-cellular resolution for this experiment, we would anticipate that the mitochondrion, the cytosol and the cytosol/nucleus classes would get high weights, while the ER and Golgi would be assigned lower weights.</p>
<p>As we use a nearest neighbour classifier, we also need to know how many neighbours to consider when classifying a protein of unknown localisation. The <em>knnOptimisation</em> function (see the <em>pRoloc-tutorial</em> vignette and the functions manual page) can be run on the primary and auxiliary data sources independently to estimate the best <span class="math inline">\(k_P\)</span> and <span class="math inline">\(k_A\)</span> values. Here, based on <em>knnOptimisation</em>, we use 3 and 3, for <span class="math inline">\(k_P\)</span> and <span class="math inline">\(k_A\)</span> respectively.</p>
<p>Finally, to assess the validity of the weight selection, it should be repeated a certain number of times (default value is 50). As the weight optimisation can become very time consuming for a wide range of weights and many target classes, we would recommend to start with a lower number of iterations, pre-analyse the results, proceed with further iterations and eventually combine the optimisation results data with the <em>combineThetaRegRes</em> function before proceeding with the selection of best weights.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">topt &lt;-<span class="st"> </span><span class="kw"><a href="../reference/knntlOptimisation.html">knntlOptimisation</a></span>(andy2011, andygoset,
                          <span class="dt">th =</span> th, 
                          <span class="dt">k =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">3</span>),
                          <span class="dt">fcol =</span> <span class="st">"markers.tl"</span>,
                          <span class="dt">times =</span> <span class="dv">50</span>)</code></pre></div>
<p>The above code chunk would take too much time to be executed in the frame of this vignette. Below, we pass a very small subset of theta matrix to minimise the computation time. The <em>knntlOptimisation</em> function supports parallelised execution using various backends thanks to the <em><a href="http://bioconductor.org/packages/BiocParallel">BiocParallel</a></em> package; an appropriate backend will be defined automatically according to the underlying architecture and user-defined backends can be defined through the <code>BPPARAM</code> argument<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. Also, in the interest of time, the weights optimisation is repeated only 5 times below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(th), <span class="dv">12</span>)
topt &lt;-<span class="st"> </span><span class="kw"><a href="../reference/knntlOptimisation.html">knntlOptimisation</a></span>(andy2011, andygoset,
                          <span class="dt">th =</span> th[i, ],
                          <span class="dt">k =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">3</span>),
                          <span class="dt">fcol =</span> <span class="st">"markers.tl"</span>,
                          <span class="dt">times =</span> <span class="dv">5</span>)</code></pre></div>
<pre><code>## Removing 428 columns with only 0s.</code></pre>
<pre><code>## Note: vector will be ordered according to classes: Cytosol Cytosol/Nucleus ER Golgi Lysosome Mitochondrion Nucleus PM Ribosome 40S Ribosome 60S (as names are not explicitly defined)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">topt</code></pre></div>
<pre><code>## Object of class "ThetaRegRes"
## Algorithm: theta 
## Theta hyper-parameters:
##  weights: 0 0.3333333 0.6666667 1 
##  k: 3 3 
##  nrow: 12 
## Design:
##  Replication: 5 x 5-fold X-validation
##  Partitioning: 0.2/0.8 (test/train)
## Results
##  macro F1:
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.7813  0.8021  0.8580  0.8485  0.8829  0.9181 
##  best theta:
##             Cytosol Cytosol.Nucleus ER Golgi Lysosome Mitochondrion
## weight:0          1               0  3     2        0             1
## weight:0.33       0               1  1     2        0             2
## weight:0.67       1               1  1     1        3             1
## weight:1          3               3  0     0        2             1
##             Nucleus PM Ribosome.40S Ribosome.60S
## weight:0          1  1            1            0
## weight:0.33       3  2            1            1
## weight:0.67       1  2            1            3
## weight:1          0  0            2            1</code></pre>
<p>The optimisation is performed on the labelled marker examples only. When removing unlabelled non-marker proteins (the <code>unknowns</code>), some auxiliary GO columns end up containing only 0 (the GO-protein association was only observed in non-marker proteins), which are temporarily removed.</p>
<p>The <code>topt</code> result stores all the result from the optimisation step, and in particular the observed theta weights, which can be directly plotted as shown on the <a href="#fig:bubble">bubble plot</a> below. These bubble plots give the proportion of best weights for each marker class that was observed during the optimisation phase. We see that the mitochondrion, the cytosol and cytosol/nucleus classes predominantly are scored with height weights (2/3 and 1), consistent with high reliability of the primary data. The Golgi and the ribosomal clusters (and to a lesser extend the ER) favour smaller scores, indicating a substantial benefit of the auxiliary data.</p>
<div class="figure">
<img src="Figures/bubble-andy.png" alt="Results obtained from an extensive optimisation on the primary andy2011 and auxiliary andygoset data sets, as produced by plot(topt). This figure is not the result for the previous code chunk, where only a random subset of 10 candidate weights have been tested." id="fig:bubble"><p class="caption">Results obtained from an extensive optimisation on the primary <code>andy2011</code> and auxiliary <code>andygoset</code> data sets, as produced by <code>plot(topt)</code>. This figure is not the result for the previous code chunk, where only a random subset of 10 candidate weights have been tested.</p>
</div>
</div>
<div id="sec:choosep" class="section level2">
<h2 class="hasAnchor">
<html><body><a href="#sec:choosep" class="anchor"> </a></body></html>Choosing weights</h2>
<p>A set of best weights must be chosen and applied to the classification of the unlabelled proteins (formally annotated as <code>unknown</code>). These can be defined manually, based on the pattern observed in the weights <a href="#fig:bubble">bubble plot</a>, or automatically extracted with the <em>getParams</em> method<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. See <em>?getParams</em> for details and the <em>favourPrimary</em> function, if it is desirable to systematically favour the primary data (i.e. high weights) when different weight combinations perform equally well.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/GenRegRes-class.html">getParams</a></span>(topt)</code></pre></div>
<pre><code>##         Cytosol Cytosol/Nucleus              ER           Golgi 
##       1.0000000       1.0000000       0.0000000       0.3333333 
##        Lysosome   Mitochondrion         Nucleus              PM 
##       0.6666667       0.3333333       0.3333333       0.3333333 
##    Ribosome 40S    Ribosome 60S 
##       0.6666667       0.6666667</code></pre>
<p>We provide the best parameters for the extensive parameter optimisation search, as provided by <em>getParams</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(bw &lt;-<span class="st"> </span><span class="kw">experimentData</span>(andy2011)<span class="op">@</span>other<span class="op">$</span>knntl<span class="op">$</span>thetas)</code></pre></div>
<pre><code>##         Cytosol Cytosol/Nucleus              ER           Golgi 
##       0.6666667       0.6666667       0.3333333       0.3333333 
##        Lysosome   Mitochondrion         Nucleus              PM 
##       0.6666667       0.6666667       0.3333333       0.3333333 
##    Ribosome 40S    Ribosome 60S 
##       0.0000000       0.3333333</code></pre>
</div>
<div id="sec:thclass" class="section level2">
<h2 class="hasAnchor">
<html><body><a href="#sec:thclass" class="anchor"> </a></body></html>Applying best <em>theta</em> weights</h2>
<p>To apply our best weights and learn from the auxiliary data accordingly when classifying the unlabelled proteins to one of the sub-cellular niches considered in <code>markers.tl</code> (as displayed on figure @ref(fig:andypca)), we pass the primary and auxiliary data sets, best weights, best k’s (and, on our case the marker’s feature variable we want to use, default would be <code>markers</code>) to the <em>knntlClassification</em> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">andy2011 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/knntlClassification.html">knntlClassification</a></span>(andy2011, andygoset,
                                <span class="dt">bestTheta =</span> bw,
                                <span class="dt">k =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">3</span>),
                                <span class="dt">fcol =</span> <span class="st">"markers.tl"</span>)</code></pre></div>
<p>This will generate a new instance of class <em>MSnSet</em>, identical to the primary data, including the classification results and classifications scores of the transfer learning classification algorithm (as <code>knntl</code> and <code>knntl.scores</code> feature variables respectively). Below, we extract the former with the <em>getPrediction</em> function and plot the results of the classification.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">andy2011 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/getPredictions.html">getPredictions</a></span>(andy2011, <span class="dt">fcol =</span> <span class="st">"knntl"</span>)</code></pre></div>
<pre><code>## ans
## Chromatin associated              Cytosol      Cytosol/Nucleus 
##                   11                  277                   56 
##             Endosome                   ER                Golgi 
##                   12                  210                   65 
##             Lysosome        Mitochondrion              Nucleus 
##                   61                  258                  108 
##                   PM         Ribosome 40S         Ribosome 60S 
##                  236                   18                   59</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/setLisacol.html">setStockcol</a></span>(<span class="kw">paste0</span>(<span class="kw"><a href="../reference/setLisacol.html">getStockcol</a></span>(), <span class="st">"80"</span>))
ptsze &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">fData</span>(andy2011)<span class="op">$</span>knntl.scores) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>
<span class="kw"><a href="../reference/plot2D.html">plot2D</a></span>(andy2011, <span class="dt">fcol =</span> <span class="st">"knntl"</span>, <span class="dt">cex =</span> ptsze)
<span class="kw"><a href="../reference/setLisacol.html">setStockcol</a></span>(<span class="ot">NULL</span>)
<span class="kw"><a href="../reference/addLegend.html">addLegend</a></span>(andy2011, <span class="dt">where =</span> <span class="st">"topright"</span>,
          <span class="dt">fcol =</span> <span class="st">"markers.tl"</span>,
          <span class="dt">bty =</span> <span class="st">"n"</span>, <span class="dt">cex =</span> .<span class="dv">7</span>)</code></pre></div>
<div class="figure">
<img src="pRoloc-transfer-learning_files/figure-html/andypca2-1.png" alt="PCA plot of `andy2011` after transfer learning classification. The size of the points is proportional to the classification scores." width="576"><p class="caption">
PCA plot of <code>andy2011</code> after transfer learning classification. The size of the points is proportional to the classification scores.
</p>
</div>
<p>Please read the <em>pRoloc-tutorial</em> vignette, and in particular the classification section, for more details on how to proceed with exploration the classification results and classification scores.</p>
</div>
</div>
<div id="sec:ccl" class="section level1">
<h1 class="hasAnchor">
<html><body><a href="#sec:ccl" class="anchor"> </a></body></html>Conclusions</h1>
<p>This vignette describes the application of a weighted <span class="math inline">\(k\)</span>-nearest neighbour transfer learning algorithm and its application to the sub-cellular localisation prediction of proteins using quantitative proteomics data as primary data and Gene Ontology-derived binary data as auxiliary data source. The algorithm can be used with various data sources (we show how to compile binary data from the Human Protein Atlas in section @ref(sec:hpaaux)) and have successfully applied the algorithm <span class="citation">(Breckels et al. 2016)</span> on third-party quantitative auxiliary data.</p>
</div>
<div id="session-information" class="section level1 unnumbered">
<h1 class="hasAnchor">
<html><body><a href="#session-information" class="anchor"> </a></body></html>Session information</h1>
<p>All software and respective versions used to produce this document are listed below.</p>
<pre><code>## R Under development (unstable) (2017-02-25 r72256)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 14.04.5 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/libf77blas.so.3.0
## LAPACK: /usr/lib/lapack/liblapack.so.3.0
## 
## locale:
##  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
##  [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
##  [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  stats     graphics  grDevices utils     datasets 
## [8] methods   base     
## 
## other attached packages:
##  [1] hpar_1.19.0          biomaRt_2.33.1       class_7.3-14        
##  [4] dplyr_0.5.0          knitr_1.16           GO.db_3.4.1         
##  [7] pRolocdata_1.15.0    pRoloc_1.17.3        MLInterfaces_1.57.0 
## [10] cluster_2.0.6        annotate_1.55.0      XML_3.98-1.7        
## [13] AnnotationDbi_1.39.0 IRanges_2.11.3       S4Vectors_0.15.2    
## [16] MSnbase_2.3.2        ProtGenerics_1.9.0   BiocParallel_1.11.1 
## [19] mzR_2.11.0           Rcpp_0.12.11         Biobase_2.37.2      
## [22] BiocGenerics_0.23.0  BiocStyle_2.5.0      pkgdown_0.1.0.9000  
## 
## loaded via a namespace (and not attached):
##   [1] backports_1.1.0       plyr_1.8.4            lazyeval_0.2.0       
##   [4] splines_3.4.0         ggvis_0.4.3           ggplot2_2.2.1        
##   [7] digest_0.6.12         foreach_1.4.3         BiocInstaller_1.27.2 
##  [10] htmltools_0.3.6       viridis_0.4.0         gdata_2.17.0         
##  [13] magrittr_1.5          memoise_1.1.0         doParallel_1.0.10    
##  [16] sfsmisc_1.1-0         limma_3.33.2          rda_1.0.2-2          
##  [19] lpSolve_5.6.13        prettyunits_1.0.2     colorspace_1.3-2     
##  [22] crayon_1.3.2          RCurl_1.95-4.8        jsonlite_1.4         
##  [25] hexbin_1.27.1         roxygen2_6.0.1        genefilter_1.59.0    
##  [28] lme4_1.1-13           impute_1.51.0         survival_2.41-3      
##  [31] iterators_1.0.8       gtable_0.2.0          zlibbioc_1.23.0      
##  [34] MatrixModels_0.4-1    car_2.1-4             kernlab_0.9-25       
##  [37] prabclus_2.2-6        DEoptimR_1.0-8        SparseM_1.77         
##  [40] scales_0.4.1          vsn_3.45.0            mvtnorm_1.0-6        
##  [43] DBI_0.6-1             viridisLite_0.2.0     xtable_1.8-2         
##  [46] progress_1.1.2        proxy_0.4-17          mclust_5.3           
##  [49] preprocessCore_1.39.0 sampling_2.8          htmlwidgets_0.8      
##  [52] threejs_0.2.2         FNN_1.1               RColorBrewer_1.1-2   
##  [55] fpc_2.1-10            modeltools_0.2-21     flexmix_2.3-14       
##  [58] nnet_7.3-12           caret_6.0-76          rlang_0.1.1          
##  [61] reshape2_1.4.2        munsell_0.4.3         mlbench_2.1-1        
##  [64] tools_3.4.0           msdata_0.17.0         RSQLite_1.1-2        
##  [67] pls_2.6-0             evaluate_0.10         stringr_1.2.0        
##  [70] mzID_1.15.0           yaml_2.1.14           ModelMetrics_1.1.0   
##  [73] robustbase_0.92-7     randomForest_4.6-12   purrr_0.2.2.2        
##  [76] dendextend_1.5.2      nlme_3.1-131          quantreg_5.33        
##  [79] whisker_0.3-2         mime_0.5              xml2_1.1.1           
##  [82] compiler_3.4.0        pbkrtest_0.4-7        e1071_1.6-8          
##  [85] affyio_1.47.0         tibble_1.3.1          stringi_1.1.5        
##  [88] highr_0.6             desc_1.1.0            lattice_0.20-35      
##  [91] trimcluster_0.1-2     Matrix_1.2-10         commonmark_1.2       
##  [94] nloptr_1.0.4          gbm_2.1.3             MALDIquant_1.16.2    
##  [97] bitops_1.0-6          httpuv_1.3.3          R6_2.2.1             
## [100] pcaMethods_1.69.0    
##  [ reached getOption("max.print") -- omitted 19 entries ]</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<html><body><a href="#references" class="anchor"> </a></body></html>References</h1>
<div id="refs" class="references">
<div id="ref-Ashburner:2000">
<p>Ashburner, M, C A Ball, J A Blake, D Botstein, H Butler, J M Cherry, A P Davis, et al. 2000. “Gene Ontology: Tool for the Unification of Biology. the Gene Ontology Consortium.” <em>Nat Genet</em> 25 (1): 25–29. doi:<a href="https://doi.org/10.1038/75556">10.1038/75556</a>.</p>
</div>
<div id="ref-Breckels:2016">
<p>Breckels, L M, S B Holden, D Wojnar, C M Mulvey, A Christoforou, A Groen, M W Trotter, O Kohlbacher, K S Lilley, and L Gatto. 2016. “Learning from Heterogeneous Data Sources: An Application in Spatial Proteomics.” <em>PLoS Comput Biol</em> 12 (5): e1004920. doi:<a href="https://doi.org/10.1371/journal.pcbi.1004920">10.1371/journal.pcbi.1004920</a>.</p>
</div>
<div id="ref-Breckels2013">
<p>Breckels, Lisa M, Laurent Gatto, Andy Christoforou, Arnoud J Groen, Kathryn S Lilley, and Matthew W B Trotter. 2013. “The Effect of Organelle Discovery Upon Sub-Cellular Protein Localisation.” <em>J Proteomics</em>, March. doi:<a href="https://doi.org/10.1016/j.jprot.2013.02.019">10.1016/j.jprot.2013.02.019</a>.</p>
</div>
<div id="ref-Christoforou:2016">
<p>Christoforou, A, C M Mulvey, L M Breckels, A Geladaki, T Hurrell, P C Hayward, T Naake, et al. 2016. “A Draft Map of the Mouse Pluripotent Stem Cell Spatial Proteome.” <em>Nat Commun</em> 7: 8992. doi:<a href="https://doi.org/10.1038/ncomms9992">10.1038/ncomms9992</a>.</p>
</div>
<div id="ref-Gatto2010">
<p>Gatto, Laurent, Juan Antonio Vizcaíno, Henning Hermjakob, Wolfgang Huber, and Kathryn S Lilley. 2010. “Organelle Proteomics Experimental Designs and Analysis.” <em>Proteomics</em>. doi:<a href="https://doi.org/10.1002/pmic.201000244">10.1002/pmic.201000244</a>.</p>
</div>
<div id="ref-Uhlen:2010">
<p>Uhlen, Mathias, Per Oksvold, Linn Fagerberg, Emma Lundberg, Kalle Jonasson, Mattias Forsberg, Martin Zwahlen, et al. 2010. “Towards a knowledge-based Human Protein Atlas.” <em>Nature Biotechnology</em> 28 (12). Nature Publishing Group, a division of Macmillan Publishers Limited. All Rights Reserved.: 1248–50. doi:<a href="https://doi.org/10.1038/nbt1210-1248">10.1038/nbt1210-1248</a>.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>We will use the sub-cellular markers defined in the <code>markers.tl</code> feature variable, instead of the default <code>markers</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Large scale applications of this algorithms were run on a cluster using an MPI backend defined with <code>SnowParams(256, type="MPI")</code>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Note that the scores extracted here are based on the random subsest of weights.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#sec:intro">Introduction</a></li>
      <li>
<a href="#sec:aux">Preparing the auxiliary data</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:goaux">The Gene Ontology</a></li>
      <li><a href="#sec:hpaaux">The Human Protein Atlas</a></li>
      <li><a href="#sec:ppi">Protein-protein interactions</a></li>
      </ul>
</li>
      <li><a href="#sec:svmtl">Support vector machine transfer learning</a></li>
      <li>
<a href="#sec:knntl">Nearest neighbour transfer learning</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:theopt">Optimal weights</a></li>
      <li><a href="#sec:choosep">Choosing weights</a></li>
      <li><a href="#sec:thclass">Applying best <em>theta</em> weights</a></li>
      </ul>
</li>
      <li><a href="#sec:ccl">Conclusions</a></li>
      <li><a href="#session-information">Session information</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Laurent Gatto, Lisa Breckels.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
