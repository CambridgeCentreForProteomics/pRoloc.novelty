%\VignetteIndexEntry{Missiing data imputation}
%\VignetteKeywords{Bioinformatics, Machine learning, Organelle, Proteomics}
%\VignettePackage{pRoloc}
\documentclass[12pt]{article}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage[auth-sc]{authblk}
\usepackage{setspace}
\onehalfspacing

\renewcommand\Authands{ and }

\newcommand{\R}{\texttt{R} }
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\mbox{\normalfont\textsf{#1}}}}
\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
%% colors
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}

\usepackage{geometry}
\geometry{verbose,
  tmargin = 2.5cm,
  bmargin = 2.5cm,
  lmargin = 3.0cm,
  rmargin = 3.0cm}

\usepackage{hyperref}
\usepackage{breakurl}
\hypersetup{%
  pdfusetitle,
  bookmarks = {true},
  bookmarksnumbered = {true},
  bookmarksopen = {true},
  bookmarksopenlevel = 2,
  unicode = {true},
  breaklinks = {false},
  hyperindex = {true},
  colorlinks = {true},
  linktocpage = {true},
  plainpages = {false},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  pdfstartview = {Fit},
  pdfpagemode = {UseOutlines},
  pdfview = {XYZ null null null}
}


\author{
  Laurent Gatto\thanks{\email{lg390@cam.ac.uk}}
}

\affil{
  Cambridge Center for Proteomics\\
  University of Cambridge
}


\begin{document}

\title{Data imputation on spatial proteomics data}

\maketitle

%% Abstract and keywords %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 0.3in minus 0.1in
\hrule
\begin{abstract}
This document illustrates the some procedures that can be use as a quality control when performing data imputation, with special emphasis on spatial/organelle proteomics data using the \Rpackage{pRoloc} package.
\end{abstract}
\textit{Keywords}: Bioinformatics, spatial/organelle proteomics, machine learning, visualisation
\vskip 0.1in minus 0.05in
\hrule
\vskip 0.2in minus 0.1in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\tableofcontents

<<env, include=FALSE, echo=FALSE, cache=FALSE>>=
options(warn = 2)
library("knitr")
opts_chunk$set(fig.align = 'center', 
               fig.show = 'hold', 
               par = TRUE,
               prompt = TRUE,
               eval = TRUE,
               comment = NA)
options(replace.assign = TRUE, 
        width = 55)

suppressPackageStartupMessages(library("MSnbase"))
suppressWarnings(suppressPackageStartupMessages(library("pRoloc")))
suppressPackageStartupMessages(library("pRolocdata"))
suppressPackageStartupMessages(library("class"))
suppressPackageStartupMessages(library("ggplot2"))
suppressPackageStartupMessages(library("reshape2"))
@ 
%%$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\section{Introduction}\label{sec:intro} 

Data imputation is performed using the \Rfunction{impute} method, defined in the \Rpackage{MSnbase} package \citep{Gatto2012}. The difficulty in performing data imputation is not the imputation itself, but making sure that the imputation procedure produces plausible results. These new values will be used for further data analysis and, eventually, interpretation of the underlying biology. As such, we advise users to assure that the imputation can be reasonably trusted and suggest some simple methods, mostly based on visualisation. 

For an introduction to \Rpackage{pRoloc}, readers are referred to the tutorial, 
available using \Rfunction{vignette("pRoloc-tutorial", package = "pRoloc")}.

<<loadpackages>>=
library("pRoloc")
library("pRolocdata")
library("reshape2")
library("ggplot2")
@ 

\section{Data imputation}

\subsubsection{Preparing test data}

<<setnNA, echo = FALSE>>=
data(tan2009r1)
nNA <- 180
pNA <- nNA / prod(dim(tan2009r1))
@ 

The \Rfunction{makeNaData} function sets \Robject{nNA} values to \Robject{NA} in a \Robject{MSnSet} instance. 
It is used to generate data sets with randomly distributed missing values.
In this case, we have set \Robject{nNA} to be \Sexpr{nNA}, which represemts \Sexpr{round(pNA, 2) * 100} \% of the data. 
This is still a relatively low proportion of missing data. 
In addition, we are going to make sure that the organelle markers, defined in 
\Robject{fData(tan2009r1)$markers$} are going to be excluded when setting missing values. 
This is done to avoid biases in the procedure described in section \ref{sec:class}.

An important point to highlight at this stage is that the simulated data generated by \Rfunction{makeNaData} 
is trully random. Non-random distribution of missing values should be addressed specifically, in the light 
of the experimental design.

<<testdata>>=
data(tan2009r1)
mrk <- fData(tan2009r1)$markers != "unknown"
nNA
set.seed(1) ## for reproducibility
tan2009NA <- makeNaData(tan2009r1, nNA, exclude = mrk)
processingData(tan2009NA)
table(fData(tan2009NA)$nNA)
@ 

\subsection{Data imputation}\label{sec:imp}

Below, we perform data imputation and compare the original values from \Robject{tan2009r1} to the 
imputed data from \Robject{tan2009imp}. The indices of the missing values are extracted with the
\Rfunction{whichNA} function and the $log_2$ ratios between the original and imputed values are 
computed and stored in the \Robject{r} variable.

<<impute>>=
tan2009imp <- impute(tan2009NA)
processingData(tan2009imp)
naIdx <- whichNA(tan2009NA)
r <- log2(exprs(tan2009r1)[naIdx]/exprs(tan2009imp)[naIdx])
summary(r)
@ 

\section{Exploring imputation}

\subsection{Exploring missing data}

See \Rfunction{MSnbase::plotNA} and other plots in old missing data vignette.

\subsection{Patterns of missing data and imputation}

We first prepare a \Robject{data.frame}, \Robject{rdf}, that stores the 
$\frac{original}{imputed}$ $log_2$ ratios, calculated in section \ref{sec:imp}. 
For visualisation purposes, the \Robject{rdf2} variable retains only 
features that have missing values.

<<rdf, tidy = FALSE>>=

rdf <- matrix(NA, 
              ncol = ncol(tan2009r1), 
              nrow = nrow(tan2009r1))
colnames(rdf) <- sampleNames(tan2009r1)
rdf[naIdx] <- r
rdf2 <- rdf[!apply(rdf, 1, function(x) all(is.na(x))), ]
rdf <- melt(rdf)
rdf2 <- melt(rdf2)
colnames(rdf2) <- colnames(rdf) <- c("y", "x", "z")

@ 

Below, we use \Rpackage{ggplot2} to colour code the ratios in the 
expression matrix. These figures illustrate the extend of the effect 
of imputation (divergence of the $log_2$ ratios from 0) as well as 
the distribution of the missing values in the expression matrix, 
inviting to reflect on the relation between possible patterns 
of missing data and their effect on imputation.
This visualisation should be particularly informative when the 
missing data is non random accross the quantitation matrix.

\begin{figure}[!hbt]
<<tileplot, fig.width=4, fig.height=6, out.width='.4\\linewidth', fig.keep='high', tidy = FALSE>>=

colscale <- c("green", "yellow", "red")
legtitle <- expression(log[2](frac(Orgiginal, Imputed)))
p <- ggplot(rdf, aes(x = x, y = y, fill = z))
p2 <- ggplot(rdf2, aes(x = x, y = y, fill = z))
p <- p + geom_tile() + theme_bw() + 
  scale_fill_gradientn(colours=colscale, na.value = NA,
                       name = legtitle)
p2 <- p2 + geom_tile() + theme_bw() + 
    scale_fill_gradientn(colours=colscale, na.value = NA,
                       name = legtitle)
print(p)
print(p2)

@ 
\caption{Position of the missing values in the data matrix. The coloured tiles 
represent the $\frac{original}{imputed}$ ratios. The figure on the right only
shows features with missing values. }
\label{fig:tile}
\end{figure}

\subsection{Effect of imputation on cluster resolution}

Visualisation of spatial proteomics data on a 2 dimensional plot using 
dimensionality reduction techniques such as principal component analysis
is enlightening in terms of quality control, as they provide a direct 
reflection on separation the cellular content and the ability to assign 
sub-cellular localisation. In this section, we make use of the 
\Rfunction{plot2D} function from \Rpackage{pRoloc}, to visualist the effect 
of imputation.

\begin{figure}[!htp]
<<plot2dimp, fig.width=8, fig.height=4, out.width='1\\linewidth', fig.keep='high', tidy = FALSE>>=

setUnknowncol("black")
par(mfrow = c(1,2))
## plot 1
plot2D(tan2009r1, cex = fData(tan2009NA)$nNA + 0.15)
title(main = "Original")
## plot 2
plot2D(tan2009imp, cex = fData(tan2009NA)$nNA + 0.15)
title(main = "Imputed")

@ 
\caption{Each figure represents the graident quantitation data as a 2 dimensional PCA plot. 
  Coloured points are organelle specific markers. We have used the number of missing values 
  per feature \Robject{fData(tan2009NA)\$nNA} to adjust the point size; the larger the 
  point, the more missing values were imputed for that feature. 
  The tiny points were complete while one feature, represented by the biggest circle, 
  had two missing values.  
}
\label{fig:plot2dimp}
\end{figure}

To fully appreciate the effect of the imputation on the data, we are going to 
combine the original and imputed data on the same figure.

<<prepdata1>>=

sel <- naIdx[, 1]
d1 <- plot2D(tan2009r1, plot = FALSE)
d2 <- plot2D(tan2009imp, plot = FALSE)
d1 <- d1[sel, ]; d2 <- d2[sel, ]
xlim <- range(range(d1[, 1]), range(d2[, 1]))
ylim <- range(range(d1[, 2]), range(d2[, 2]))

@ 


<<prepdata2>>=

p1 <- exprs(tan2009r1)[sel, ]
p2 <- exprs(tan2009imp)[sel, ]
impdists <- sapply(1:nrow(p1),
                   function(i) dist(rbind(p1[i, ], p2[i, ])))
ddf <- data.frame(nNA = factor(fData(tan2009NA)$nNA[sel]),
                  distance = impdists)
pp <- qplot(nNA, distance, data = ddf, geom = "boxplot")

@ 

\begin{figure}[!htp]
<<plot2dimp2, out.width='.45\\linewidth', fig.keep='high', tidy = FALSE>>=

plot(d1[, 1], d1[, 2], pch = 1, 
     cex = fData(tan2009NA)$nNA[sel],
     xlab = "PC1", ylab = "PC2", 
     xlim = xlim, ylim = ylim,
     main = "Effect of imputation")
grid()
points(d2[, 1], d2[, 2], pch = "+", 
       cex = fData(tan2009NA)$nNA[sel])
segments(d1[, 1], d1[, 2], 
         d2[, 1], d2[, 2],
         col = "grey50")
print(pp)

@ 
\caption{On this figure, we represent the imputed features only. 
  The circles represent the location of the original values and 
  crosses represent positions after imputation. }
\label{fig:plot2dimp2}
\end{figure}

The effect of imputation can not be applied on real missing data 
as discribed above. Visualisation on the PCA plot, and 
\Rfunction{plot2D} can still be applied on the complete and the 
imputed data.

\subsection{Effect of imputation on classification}\label{sec:class}

In this section, we are going to proceed and assess the effect of imputation 
on the classification itself. We are going to perform classification on two 
data set, filtered and imputed, and compare the classification results. 
The extend to which the classification results disagree will reflect the 
effect of the imputation.

\subsubsection{Classification of the filtered data}

<<loadpar1, echo = FALSE>>=
tan2009filt <- filterNA(tan2009NA)
load(dir(system.file("extdata", package = "pRoloc"), 
         full.names = TRUE, pattern = "par1.rda"))
@ 

We first filter the data containing \Robject{NA} values with the 
\Rfunction{filterNA} method, that will remove fetaures that contain 
missing values (see \Rfunction{?filterNA} for further parametrisation).
Before proceeding with the actual classification, we optimise the 
\Robject{sigma} and \Robject{cost} parameters using 
\Rfunction{svmOptimisation}\footnote{%%
In the interest of time, \Rfunction{svmOptimisation} is not executed when the 
vignette is dynamically built. The \Robject{par1} object can be located with 
\Rfunction{dir(system.file("extdata", package = "pRoloc"), full.names = TRUE, pattern = "par1.rda")} 
and loaded with \Rfunction{load}.}%%
(see \Rfunction{vignette("pRoloc-tutorial")} 
and \Rfunction{?svmOptimisation} for details). 
We set the random number generator 
seed to 1, as we will do later, to assure comparability of 
optimisation routines.

<<par1, tidy = FALSE, eval = FALSE>>=
tan2009filt <- filterNA(tan2009NA)
par1 <- svmOptimisation(tan2009filt, seed = 1, verbose = FALSE)
## checking levelPlot(par1), plot(par1), getParams(par1) and f1Count(par1)
@ 

We them apply a standard supervised classification procedure using 
support vector machines, as implemented in \Rpackage{pRoloc} 
(see \Rfunction{vignette("pRoloc-tutorial")} and 
\Rfunction{?svmClassification} for more details).

<<cl1, tidy = FALSE, warning = FALSE>>=

cl1 <- svmClassification(tan2009filt, cost = 1, sigma = 0.1)
summary(fData(cl1)$svm.scores)
## plot2D(cl1, fcol = "svm", fpch = "markers", 
##        cex = fData(cl1)$svm.scores + 0.2)
pred1 <- getPredictions(cl1, fcol = "svm", 
                        t = median(fData(cl1)$svm.scores))
fData(cl1)$pred1 <- pred1

@ 

\subsubsection{Classification of the imputed data}

<<loadpar2, echo = FALSE>>=
load(dir(system.file("extdata", package = "pRoloc"), 
         full.names = TRUE, pattern = "par2.rda"))
@ 

Below we repeat the parameter optimisation using \Rfunction{svmOptimisation}\footnote{%%
  As previously, the results are pre-computed and loaded in the interest of time.
}.

<<par2, tidy = FALSE, eval = FALSE>>=
par2 <- svmOptimisation(tan2009imp, seed = 1, verbose = FALSE)
## checking levelPlot(par2), plot(par2), getParams(par2) and f1Count(par2)
@ 

Here we classify the imputed data, setting \Robject{sigma} and \Robject{cost} to 1.

<<cl2, tidy = FALSE, warning = FALSE>>=
cl2 <- svmClassification(tan2009imp, sigma = 1, cost = 1)
summary(fData(cl2)$svm.scores)
## plot2D(cl2, fcol = "svm", fpch = "markers", 
##        cex = fData(cl2)$svm.scores + 0.2)
pred2 <- getPredictions(cl2, fcol = "svm", 
                        t = median(fData(cl2)$svm.scores))
fData(cl2)$pred2 <- pred2
@ 

\subsubsection{Comparison of the classification results}

\begin{figure}[!htp]
<<comp1, out.width='.45\\linewidth', fig.keep='high'>>=
plot2D(cl1, fcol = "pred1", main = "Filtered data")
plot2D(cl2, fcol = "pred2", main = "Imputed data")
@ 
\caption{Caption... }
\label{fig:comp1}
\end{figure}

<<comp2, tidy = FALSE>>=
table(fData(cl1)$pred1,
      fData(cl2)[featureNames(cl1), "pred2"])
@ 

<<markers>>=
getMarkers(tan2009imp)
getMarkers(tan2009filt)
@ 

\subsection{An iterative approach}

\subsubsection{Test data}

<<testdata2>>=
data(dunkley2006)
prep1 <- dunkley2006$membrane.prep == 1
dunkleyNA <- dunkley2006[, prep1]
set.seed(1)
dunkleyNA <- makeNaData2(dunkley2006,
                         nRows = rep(10, 5),
                         nNAs = 1:5)
processingData(dunkleyNA)
@ 

\singlespacing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage

\section*{Session information}\label{sec:sessionInfo} 

All software and respective versions used to produce this document are listed below.

<<sessioninfo, results='asis', echo=FALSE>>=
toLatex(sessionInfo())
@

\bibliographystyle{plainnat}
\bibliography{pRoloc}

\end{document}

